#!/usr/bin/env python3
# FIXME: own custom classes or numpy arrays?

from argparse import ArgumentParser
from collections import Counter
from functools import partial
from os.path import isfile
from random import sample
from sys import stdin, stdout
import time

from numpy import array
from yaml import load as yload, dump as ydump

try:
    from yaml import CLoader as YLoader
except ImportError:
    from yaml import Loader as YLoader

try:
    from yaml import CDumper as YDumper
except ImportError:
    from yaml import YDumper

from vectorpack.packs import get_pack_by_name
from vectorpack.sorts import get_sort_key_by_name
from vectorpack.selects import get_select_by_name
from vectorpack.util import verify_mapping, negate_func, zero


def parse_sort_cmdline(sortcmd):
    args = sortcmd.split(":")

    arg = args.pop(0)
    desc = False
    if arg in [ "a", "d" ]:
        if arg is "d":
            desc = True
        arg = args.pop(0)

    sort_key = get_sort_key_by_name(arg)

    kwargs = {}
    if args:
        kwargs.update(yload("\n".join(arg.replace('=', ': ') for arg in args)))

    if desc:
        return partial(negate_func, sort_key, **kwargs)

    if kwargs:
        return partial(sort_key, **kwargs)

    return sort_key


def parse_select_cmdline(sortcmd):
    args = sortcmd.split(":")

    arg = args.pop(0)
    desc = False
    if arg in [ "a", "d" ]:
        if arg is "d":
            desc = True
        arg = args.pop(0)

    select_key = get_select_by_name(arg)

    kwargs = {}
    if args:
        kwargs.update(yload("\n".join(arg.replace('=', ': ') for arg in args)))

    if desc:
        return partial(negate_func, select_key, **kwargs)

    if kwargs:
        return partial(select_key, **kwargs)

    return select_key


def main(argv=None):

    parser = ArgumentParser(description="Solve a vector packing problem.")
    parser.add_argument('-i', '--inputfile', help='input file')
    parser.add_argument('-o', '--outputfile', default='-', help='output file')
    parser.add_argument('-P', '--pack', default='pack_by_bins', 
                        help='packing algorithm')
    parser.add_argument('-I', '--itemsort', default='none', 
                        help='item sorting algorithm')
    parser.add_argument('-B', '--binsort', default='none', 
                        help='bin sorting algorithm')
    parser.add_argument('-S', '--select', default='none', 
                        help='pairwise selection algorithm')
    parser.add_argument('-s', '--split', default=0, type=int,
                        help='split the problem')

    args = parser.parse_args()

    problem = {}
    if isfile(args.inputfile):
        problem = yload(open(args.inputfile, 'r'), Loader=YLoader)
    else:
        raise SystemExit("error: can't find file %s" % args.inputfile)

    items = problem.get('items', None)
    bins = problem.get('bins', None)
    pack = get_pack_by_name(args.pack)
    item_key = parse_sort_cmdline(args.itemsort)
    bin_key = parse_sort_cmdline(args.binsort)
    select_key = parse_select_cmdline(args.select)

    mapping = []

    if args.split > 0:
        # FIXME? alternate implementation would be to generate set of indexes,
        # build map from that, might be more elegant.
        start_time = time.process_time()
        enum_items = set(enumerate(tuple(item) for item in items))
        enum_bins = set(enumerate(tuple(bin_) for bin_ in bins))
        enum_items_sublist_size = int((float(len(items)) / args.split) + 0.5)
        enum_bins_sublist_size = int((float(len(bins)) / args.split) + 0.5)
        mapping = [None] * len(items)
        for i in range(args.split):
            enum_items_sublist = list(enum_items)
            if enum_items_sublist_size < len(enum_items_sublist):
                enum_items_sublist = sample(enum_items, enum_items_sublist_size)
            enum_items -= set(enum_items_sublist)
            enum_bins_sublist = list(enum_bins)
            if enum_bins_sublist_size < len(enum_bins_sublist):
                enum_bins_sublist = sample(enum_bins, enum_bins_sublist_size)
            enum_bins -= set(enum_bins_sublist)
            items_tmp = [i for pi, i in enum_items_sublist]
            bins_tmp = [b for pb, b in enum_bins_sublist]
            mapping_tmp = pack(items=items_tmp, bins=bins_tmp, 
                           item_key=item_key, bin_key=bin_key, 
                           select_key=select_key)
            if mapping_tmp is None:
                mapping = None
                break
            for i, b in enumerate(mapping_tmp):
                mapping[enum_items_sublist[i][0]] = enum_bins_sublist[b][0]
        stop_time = time.process_time()
                
    else:
        start_time = time.process_time()
        mapping = pack(items=items, bins=bins, 
                       item_key=item_key, bin_key=bin_key, 
                       select_key=select_key)
        stop_time = time.process_time()

    solution = {
        'problem-argshash' : problem.get('argshash', None),
        'pack' : args.pack,
        'itemsort' : args.itemsort,
        'binsort' : args.binsort,
        'select' : args.select,
        'success' : mapping is not None,
        'mapping' : mapping,
        'bincount' : len(Counter(mapping)),
        'runtime' : stop_time - start_time,
        'verified' : verify_mapping(items=items, bins=bins, mapping=mapping)
    }

    print(ydump(solution, Dumper=YDumper))
    

if __name__ == "__main__":
    main() 
