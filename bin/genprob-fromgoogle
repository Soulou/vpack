#!/usr/bin/env python

def main(argv=None):
    from argparse import ArgumentParser
    from gzip import GzipFile
    import os
    import random
    import sys

    import pandas as pd

    parser = ArgumentParser(
        description="Generat a random problem instance using google data.")
    parser.add_argument('-s', '--seed', type=int, 
                        help='seed for random number generator')
    parser.add_argument('-g', '--googledir', 
                        help='path to google-clusterdata-2011-1 directory')
    parser.add_argument('-i', '--indexfile', 
                        help='path to google task_usage-startend-index file')

    parser.add_argument('-c', '--cpuslack', 
                        help='cpu slack')

    parser.add_argument('-m', '--memslack', 
                        help='memory slack')
    args = parser.parse_args()

    random.seed(args.seed) 

    # get task population data from google dataset
    file_index = pd.read_csv(
        args.indexfile, header=None, index_col=False,
        names=['filename', 'min_timestamp', 'max_timestamp'])
    min_timestamp = min(file_index['min_timestamp'])
    max_timestamp = max(file_index['max_timestamp'])
    moment = random.randint(min_timestamp, max_timestamp)
    task_population = dict()
    file_list = file_index[(file_index['min_timestamp'] <= moment) &
                       (moment <= file_index['max_timestamp'])]['filename']

    usage_data = pd.concat(
        pd.read_csv(
                 os.path.join(args.googledir, 'task_usage', fname),
                 compression='gzip',
                 names=['start_time', 'end_time', 
                        'job_id', 'task_idx', 'machine_id', 
                        'cpu_rate', 'canonical_mem_usage', 
                        'assigned_mem_usage', 
                        'unmapped_page_cache', 'total_page_cache', 
                        'max_mem_usage', 'disk_io', 'local_disk_space_usage', 
                        'max_cpu_rate', 'max_disk_io_time', 'cpi', 'mapi', 
                        'sample_portion', 'agg_type'])
        for fname in file_list)
    task_population = usage_data[(usage_data['start_time'] <= moment) &
                            (moment <= usage_data['end_time'])]

    # get machine data from google
    machine_events = pd.read_csv(
        os.path.join(args.googledir, 
                     'machine_events/part-00000-of-00001.csv.gz'),
        compression='gzip',
        names=['timestamp', 'machine_id', 'event_type', 'platform_id', 
               'cpu', 'mem'])
    machine_events = machine_events[machine_events['timestamp'] <= moment].sort(
        columns=['timestamp'])
   
    machine_population = dict()
    for event in machine_events.irows():
        timestamp = int(timestamp_str)
        event_type = int(event_type_str)
        if timestamp <= moment:
            if event_type in [0, 2]:
                try:
                    cpu = float(cpu_str)
                    mem = float(mem_str)
                    machine_population[machine_id] = (cpu, mem)
                except ValueError:
                    pass
            elif event_type == 1:
                del machine_population[machine_id]
            
    print len(machine_population), len(task_population)
    print "cpu:", sum(cpu for cpu, mem in task_population.values()), "/", sum(cpu for cpu, mem in machine_population.values()), \
          sum(cpu for cpu, mem in task_population.values()) / sum(cpu for cpu, mem in machine_population.values())

    print "mem:", sum(mem for cpu, mem in task_population.values()), "/", sum(mem for cpu, mem in machine_population.values()), \
          sum(mem for cpu, mem in task_population.values()) / sum(mem for cpu, mem in machine_population.values())

    task_sample = random.sample(task_population.values(), 4096)
    machine_sample = random.sample(machine_population.values(), 512) 
    print len(machine_sample), len(task_sample)
    print "cpu:", sum(cpu for cpu, mem in task_sample), "/", sum(cpu for cpu, mem in machine_sample), \
          sum(cpu for cpu, mem in task_sample) / sum(cpu for cpu, mem in machine_sample)
    print "mem:", sum(mem for cpu, mem in task_sample), "/", sum(mem for cpu, mem in machine_sample), \
          sum(mem for cpu, mem in task_sample) / sum(mem for cpu, mem in machine_sample)
    

if __name__ == "__main__":
    main()
